
## 用 key 强制重置组件状态

```tsx
function SearchBox() {
  const [v, setV] = React.useState("");
  const [resetSeed, setResetSeed] = React.useState(0);

  return (
    <>
      <input
        key={resetSeed} // key 变了 => input 完整重建 => 状态被重置
        value={v}
        onChange={e => setV(e.target.value)}
        placeholder="输入关键词"
      />
      <button
        onClick={() => {
          setV("");
          setResetSeed(s => s + 1);
        }}
      >
        清空并重置
      </button>
    </>
  );
}
```


## 抛出 Promise，让 Suspense 接管加载

```tsx
const cache = new Map();

function fetchUser(id) {
  if (cache.has(id)) return cache.get(id);

  const p = fetch(`/api/user/${id}`).then(r => r.json());
  cache.set(id, p);

  throw p; // 未完成 => 让 <Suspense> 兜底
}

function UserCard({ id }) {
  const user = fetchUser(id); // 完成后这里得到数据
  return <div>{user.name}</div>;
}

export default function Page() {
  return (
    <React.Suspense fallback={<div>加载中…</div>}>
      <UserCard id="42" />
    </React.Suspense>
  );
}
```
## 回调 ref 替代副作用拿 DOM

```tsx
function AutoFocusInput() {
  const ref = React.useCallback(node => {
    if (node) node.focus(); // mount 时拿到节点，同步执行
  }, []);

  return <input ref={ref} placeholder="自动聚焦" />;
}
```

## 直接取最新值

```tsx
function useLatest(value) {
  const box = React.useRef(value);
  box.current = value;
  return box;
}

function Chat({ onSend }) {
  const [text, setText] = React.useState("");
  const latest = useLatest(text);

  const handleKey = React.useCallback(
    e => {
      if (e.key === "Enter") onSend(latest.current);
    },
    [onSend] // 不依赖 text，也总是最新
  );

  return (
    <input
      value={text}
      onChange={e => setText(e.target.value)}
      onKeyDown={handleKey}
    />
  );
}


```

## “受控/非受控”混搭 + key：大表单秒回填、不抖动

```tsx
function ProfileForm({ draft }) {
  // 当 draft.id 变化时整表单重建，defaultValue 生效，不会受控抖动
  return (
    <form key={draft.id}>
      <input name="name" defaultValue={draft.name} />
      <input name="email" defaultValue={draft.email} />
      {/* 需要联动校验的个别字段再做受控 */}
    </form>
  );
}

```

## 6. 把状态下沉到 CSS 变量

```tsx
function HeatMap({ intensity }) {
  return (
    <div style={{ "--int": intensity }} className="heat-wrap">
      <Cells /> {/* 大量静态子节点，无需随状态 re-render */}
    </div>
  );
}
```

## 局部 flushSync，避免动画闪烁

```tsx
import { flushSync } from "react-dom";

function List() {
  const [items, setItems] = React.useState([1, 2, 3]);
  const listRef = React.useRef(null);

  function add() {
    flushSync(() => setItems(s => [Date.now(), ...s])); // 立刻更新 DOM
    const first = listRef.current.firstElementChild;
    first?.scrollIntoView({ behavior: "instant", block: "nearest" });
  }

  return <ul ref={listRef}>{items.map(i => <li key={i}>{i}</li>)}</ul>;
}

```
## 8. Fragment 也能挂 key

```tsx
function Panel({ mode }) {
  return (
    <>
      <StaticHeader />
      <React.Fragment key={mode}>
        {/* 这里的所有子组件在 mode 切换时都会重挂载 */}
        <Workspace mode={mode} />
      </React.Fragment>
    </>
  );
}

```


## 9. Portal 渲染，全局弹层依旧能冒泡事件

```tsx
import { createPortal } from "react-dom";

function Modal({ open, onClose, children }) {
  if (!open) return null;
  return createPortal(
    <div className="mask" onClick={onClose}>
      <div className="box" onClick={e => e.stopPropagation()}>
        {children}
      </div>
    </div>,
    document.body
  );
}

function Page() {
  const [open, setOpen] = React.useState(false);
  return (
    <div onKeyDown={e => e.key === "Escape" && setOpen(false)}>
      <button onClick={() => setOpen(true)}>打开</button>
      <Modal open={open} onClose={() => setOpen(false)}>
        内容
      </Modal>
    </div>
  );
}

```

## useTransition 瞬时交互 + 并发计算

```tsx
function Finder({ data }) {
  const [query, setQuery] = React.useState("");
  const [list, setList] = React.useState(data);
  const [isPending, startTransition] = React.useTransition();

  function onChange(e) {
    const q = e.target.value;
    setQuery(q); // 立即更新输入框
    startTransition(() => {
      // 把重计算放在并发队列
      const next = data.filter(x => x.includes(q));
      setList(next);
    });
  }

  return (
    <>
      <input value={query} onChange={onChange} placeholder="搜索…" />
      {isPending && <small>计算中…</small>}
      <ul>{list.map(i => <li key={i}>{i}</li>)}</ul>
    </>
  );
}


```